#include "clist.h"
#include <iostream>
#include <cstring>
#include <cctype>
using namespace std;

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to display the list. Return the number of nodes.
//The difficulty of this question is: 0

/*
int displayAll(node* head)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to display the list in reverse order. Return the number of nodes.
//The difficulty of this question is: 0

/*
int displayReverse(node* head)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to display every node that is divisible by the argument passed in. Return number of nodes displayed.
//The difficulty of this question is: 0

/*
int displayDivisible(node* head, int toDisplay)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to display every other Node in the list. Return the number of nodes that are not displayed.
//The difficulty of this question is: 1

/*
int displayEveryOther(node* head)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to add the sum of the data from the first two nodes to the end of the list. Return the sum of the list. 
//The difficulty of this question is: 1

/*
int addToEnd(node*& head)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to add the data passed in to the function after every instance of a 2 in the list. Return the number of nodes that were added to the list.
//The difficulty of this question is: 1

/*
int addAfter2(node*& head, int toAdd)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to add the data passed in to the function before every instance of a 2 in the list. Return the number of nodes that were added to the list.
//The difficulty of this question is: 1

/*
int addBefore2(node*& head, int toAdd)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to add the data of the first node that is divisible by three or five to every following node in the list. Return number of nodes that occur before one is divisible by three or five.
//The difficulty of this question is: 3

/*
int modifyAfter(node* head)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to reverse the List. Return number of nodes in the list.
//The difficulty of this question is: 3

/*
int reverseAll(node*& head)
{
}
*/

//Place the prototype in the appropriate .h file
//Consider:
//Do you need helper functions?
//Is head or tail recursion better?
//Remove the block comments form the function below to get started
//The question is: Write a function to add a node that contains the data passed into the function at the end of the list for each node that is divisible by the first node's data
//The difficulty of this question is: 3

/*
int appendIfDivisible (node*& head, int toAdd)
{
}
*/

